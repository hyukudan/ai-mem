#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: ./scripts/install-neovim.sh [--dest PATH] [--bin PATH] [--force]

Creates a Lua module for ensuring ai-mem integration in Neovim.

Options:
  --dest PATH   Target Lua file path (default: $HOME/.config/nvim/lua/ai-mem.lua)
  --bin PATH    ai-mem binary path (default: ai-mem)
  --force       Overwrite existing file
EOF
}

dest_path="$HOME/.config/nvim/lua/ai-mem.lua"
bin_path="ai-mem"
force="false"

while [ $# -gt 0 ]; do
  case "$1" in
    --dest)
      dest_path="${2:-}"
      shift 2
      ;;
    --bin)
      bin_path="${2:-}"
      shift 2
      ;;
    --force)
      force="true"
      shift 1
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

dest_dir="$(dirname "$dest_path")"
mkdir -p "$dest_dir"

if [ -f "$dest_path" ] && [ "$force" != "true" ]; then
  echo "File already exists: $dest_path (use --force to overwrite)"
  exit 0
fi

# We use python to safely generate the Lua content with injected binary path
python3 - "$dest_path" "$bin_path" <<'PY'
import sys

dest_path = sys.argv[1]
bin_path = sys.argv[2]

lua_content = f"""-- ai-mem Neovim Integration
-- Auto-generated by install-neovim.sh

local M = {{}}
local bin = "{bin_path}"

function M.setup(opts)
    if opts and opts.bin then
        bin = opts.bin
    end
end

local function run_bg(args)
    local cmd = {{bin, "hook"}}
    for _, a in ipairs(args) do table.insert(cmd, a) end
    
    -- Properly quote arguments if needed (simple approximation)
    local cmd_str = table.concat(cmd, " ")
    
    -- Run in background
    os.execute(cmd_str .. " &")
end

local function run_capture(args)
    local cmd = {{bin}}
    for _, a in ipairs(args) do table.insert(cmd, a) end
    local cmd_str = table.concat(cmd, " ")
    local handle = io.popen(cmd_str)
    local result = handle:read("*a")
    handle:close()
    return result
end

function M.session_start()
    local project = vim.fn.getcwd()
    run_bg({{"session_start", "--project", project, "--session-tracking"}})
    print("ai-mem: Session started")
end

function M.session_end()
    local project = vim.fn.getcwd()
    run_bg({{"session_end", "--project", project, "--session-tracking", "--summary-on-end"}})
    print("ai-mem: Session ended")
end

function M.add_note()
    local input = vim.fn.input("Note: ")
    if input == "" then return end
    local project = vim.fn.getcwd()
    -- We use popen/write for safety with input or just construct arg
    -- For simplicity in this preset, we pass as arg. Note: complex chars might need better quoting.
    run_bg({{"user_prompt", "--project", project, "--content", string.format("%q", input)}})
    print("ai-mem: Note added")
end

function M.add_selection()
    -- Get visual selection
    local _, ls, cs = unpack(vim.fn.getpos("'<"))
    local _, le, ce = unpack(vim.fn.getpos("'>"))
    local lines = vim.fn.getline(ls, le)
    if type(lines) == "string" then lines = {{lines}} end
    if #lines == 0 then return end
    local content = table.concat(lines, "\\n")
    
    local project = vim.fn.getcwd()
    -- We pipe content to avoid shell quoting issues
    local cmd = string.format("echo %q | %s hook user_prompt --project %q --content-file -", content, bin, project)
    os.execute(cmd .. " &")
    print("ai-mem: Selection added")
end

function M.context()
    local project = vim.fn.getcwd()
    local result = run_capture({{"context", "--project", project, "--show-tokens"}})
    
    -- Open in a scratch buffer
    vim.cmd("new")
    local buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, vim.split(result, "\\n"))
    vim.api.nvim_buf_set_option(buf, "buftype", "nofile")
    vim.api.nvim_buf_set_option(buf, "filetype", "markdown")
end

-- Commands
vim.api.nvim_create_user_command("AIMemStart", M.session_start, {{}})
vim.api.nvim_create_user_command("AIMemEnd", M.session_end, {{}})
vim.api.nvim_create_user_command("AIMemNote", M.add_note, {{}})
vim.api.nvim_create_user_command("AIMemContext", M.context, {{}})
vim.api.nvim_create_user_command("AIMemSel", M.add_selection, {{range = true}})

return M
"""

with open(dest_path, "w", encoding="utf-8") as f:
    f.write(lua_content)

print(f"Wrote {dest_path}")
PY
chmod +x "$dest_path" 2>/dev/null || true
