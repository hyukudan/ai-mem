"""Folder Context Files - Automatic CLAUDE.md generation per directory.

This module generates and maintains CLAUDE.md files in project directories,
providing contextual information about activity in each folder.

Each CLAUDE.md contains:
- Timeline of activity for that directory
- Table: ID, time, type, title, token cost
- Updated automatically when observations are added

Configuration:
    AI_MEM_FOLDER_CLAUDEMD_ENABLED=true
    AI_MEM_FOLDER_CLAUDEMD_MAX_ENTRIES=20
"""

import asyncio
import json
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from .config import load_config
from .context import estimate_tokens
from .logging_config import get_logger
from .memory import MemoryManager

logger = get_logger("folder_context")

# Default settings
DEFAULT_MAX_ENTRIES = 20
DEFAULT_FILENAME = "CLAUDE.md"

# Configuration via environment
FOLDER_CLAUDEMD_ENABLED = os.environ.get("AI_MEM_FOLDER_CLAUDEMD_ENABLED", "false").lower() in ("true", "1", "yes")
FOLDER_CLAUDEMD_MAX_ENTRIES = int(os.environ.get("AI_MEM_FOLDER_CLAUDEMD_MAX_ENTRIES", DEFAULT_MAX_ENTRIES))
FOLDER_CLAUDEMD_FILENAME = os.environ.get("AI_MEM_FOLDER_CLAUDEMD_FILENAME", DEFAULT_FILENAME)


def is_enabled() -> bool:
    """Check if folder CLAUDE.md generation is enabled."""
    return FOLDER_CLAUDEMD_ENABLED


def get_folder_from_observation(obs: Dict[str, Any]) -> Optional[str]:
    """Extract the folder path from an observation.

    Looks at tool input, metadata, or content for file paths.

    Args:
        obs: Observation dictionary

    Returns:
        Folder path or None
    """
    # Check metadata for file paths
    metadata = obs.get("metadata") or {}

    # Look for file path in common locations
    file_path = None

    # From tool input
    tool_input = metadata.get("tool_input") or {}
    if isinstance(tool_input, dict):
        file_path = tool_input.get("path") or tool_input.get("file_path") or tool_input.get("file")
    elif isinstance(tool_input, str):
        # Check if it looks like a path
        if "/" in tool_input or "\\" in tool_input:
            file_path = tool_input

    # From files_touched
    files_touched = metadata.get("files_touched") or []
    if files_touched and not file_path:
        file_path = files_touched[0]

    # Extract from content (look for file paths)
    if not file_path:
        content = obs.get("content") or ""
        # Simple pattern for file paths
        match = re.search(r'(?:^|["\s])(/[a-zA-Z0-9_/.-]+\.[a-z]+)', content)
        if match:
            file_path = match.group(1)

    if not file_path:
        return None

    # Get directory from file path
    path = Path(file_path)
    if path.is_file():
        return str(path.parent)
    elif path.is_dir():
        return str(path)

    # Assume it's a file if it has an extension
    if path.suffix:
        return str(path.parent)

    return None


def format_observation_row(obs: Dict[str, Any]) -> str:
    """Format an observation as a markdown table row.

    Args:
        obs: Observation dictionary

    Returns:
        Markdown table row
    """
    obs_id = obs.get("id", "")[:8]
    created_at = obs.get("created_at", 0)
    obs_type = obs.get("type", "-")
    concept = obs.get("concept")
    title = obs.get("title") or obs.get("summary") or obs.get("content", "")[:50]
    title = title.replace("|", "\\|").replace("\n", " ")[:60]

    # Calculate tokens
    content = obs.get("content") or obs.get("summary") or ""
    tokens = estimate_tokens(content)

    # Format time
    time_str = datetime.fromtimestamp(created_at).strftime("%H:%M") if created_at else "-"

    # Type/concept display
    type_display = obs_type
    if concept:
        type_display = f"{obs_type}/{concept}"

    return f"| {obs_id} | {time_str} | {type_display} | {title} | ~{tokens} |"


def generate_folder_claudemd(
    folder_path: str,
    observations: List[Dict[str, Any]],
    project: str,
    max_entries: int = DEFAULT_MAX_ENTRIES,
) -> str:
    """Generate CLAUDE.md content for a folder.

    Args:
        folder_path: Path to the folder
        observations: List of observations for this folder
        project: Project path
        max_entries: Maximum entries to include

    Returns:
        Markdown content
    """
    lines = [
        "# Folder Context",
        "",
        f"> Auto-generated by ai-mem | {datetime.now().strftime('%Y-%m-%d %H:%M')}",
        "",
        f"**Folder:** `{folder_path}`",
        f"**Project:** `{project}`",
        "",
        "## Recent Activity",
        "",
        "| ID | Time | Type | Title | Tokens |",
        "|---|---|---|---|---|",
    ]

    # Add observations
    sorted_obs = sorted(observations, key=lambda x: x.get("created_at", 0), reverse=True)

    for obs in sorted_obs[:max_entries]:
        lines.append(format_observation_row(obs))

    # Add footer
    lines.extend([
        "",
        "---",
        "",
        f"*{len(observations)} total observations in this folder.*",
        "",
        "Use `ai-mem search` to find specific entries.",
    ])

    return "\n".join(lines)


async def update_folder_claudemd(
    manager: MemoryManager,
    folder_path: str,
    project: str,
    max_entries: int = DEFAULT_MAX_ENTRIES,
    filename: str = DEFAULT_FILENAME,
) -> Optional[str]:
    """Update or create CLAUDE.md for a folder.

    Args:
        manager: MemoryManager instance
        folder_path: Path to the folder
        project: Project path
        max_entries: Maximum entries to include
        filename: Name of the file (default: CLAUDE.md)

    Returns:
        Path to the created file, or None if no observations
    """
    if not is_enabled():
        logger.debug("Folder CLAUDE.md disabled")
        return None

    folder = Path(folder_path)
    if not folder.exists() or not folder.is_dir():
        logger.debug(f"Invalid folder path: {folder_path}")
        return None

    # Get observations for this folder
    all_obs = await manager.db.list_observations(project=project, limit=200)

    # Filter to this folder
    folder_obs = []
    for obs_idx in all_obs:
        obs_dict = await manager.db.get_observation(obs_idx.id)
        if not obs_dict:
            continue
        obs_folder = get_folder_from_observation(obs_dict)
        if obs_folder and (obs_folder == str(folder) or obs_folder.startswith(str(folder) + "/")):
            folder_obs.append(obs_dict)

    if not folder_obs:
        logger.debug(f"No observations for folder: {folder_path}")
        return None

    # Generate content
    content = generate_folder_claudemd(
        folder_path=str(folder),
        observations=folder_obs,
        project=project,
        max_entries=max_entries,
    )

    # Write file
    output_path = folder / filename
    try:
        output_path.write_text(content, encoding="utf-8")
        logger.info(f"Updated {filename}: {output_path}")
        return str(output_path)
    except Exception as e:
        logger.warning(f"Failed to write {filename}: {e}")
        return None


async def update_project_claudemds(
    manager: MemoryManager,
    project: str,
    max_entries: int = DEFAULT_MAX_ENTRIES,
    filename: str = DEFAULT_FILENAME,
) -> List[str]:
    """Update CLAUDE.md files for all folders in a project.

    Args:
        manager: MemoryManager instance
        project: Project path
        max_entries: Maximum entries per file
        filename: Name of the file

    Returns:
        List of created file paths
    """
    if not is_enabled():
        return []

    project_path = Path(project)
    if not project_path.exists() or not project_path.is_dir():
        return []

    # Get all observations for project
    all_obs = await manager.db.list_observations(project=project, limit=500)

    # Group by folder
    folder_obs: Dict[str, List[Dict[str, Any]]] = {}

    for obs_idx in all_obs:
        obs_dict = await manager.db.get_observation(obs_idx.id)
        if not obs_dict:
            continue
        obs_folder = get_folder_from_observation(obs_dict)
        if obs_folder:
            folder_obs.setdefault(obs_folder, []).append(obs_dict)

    # Update each folder
    created_files = []
    for folder, observations in folder_obs.items():
        if len(observations) >= 3:  # Only create if enough activity
            content = generate_folder_claudemd(
                folder_path=folder,
                observations=observations,
                project=project,
                max_entries=max_entries,
            )
            output_path = Path(folder) / filename
            try:
                output_path.write_text(content, encoding="utf-8")
                created_files.append(str(output_path))
            except Exception as e:
                logger.warning(f"Failed to write {output_path}: {e}")

    return created_files


class FolderContextHook:
    """Hook to update CLAUDE.md files when observations are added.

    Usage:
        hook = FolderContextHook(manager)
        hook.register()  # Register with manager's event system
    """

    def __init__(self, manager: MemoryManager):
        """Initialize hook.

        Args:
            manager: MemoryManager instance
        """
        self.manager = manager
        self._pending_folders: Dict[str, float] = {}  # folder -> last_update_time
        self._update_interval = 60  # Minimum seconds between updates

    async def on_observation_added(self, obs: Dict[str, Any]) -> None:
        """Handle observation added event.

        Args:
            obs: The added observation
        """
        if not is_enabled():
            return

        folder = get_folder_from_observation(obs)
        if not folder:
            return

        project = obs.get("project")
        if not project:
            return

        # Debounce updates
        import time
        now = time.time()
        last_update = self._pending_folders.get(folder, 0)

        if now - last_update < self._update_interval:
            logger.debug(f"Skipping update for {folder} (too recent)")
            return

        self._pending_folders[folder] = now

        # Schedule update
        asyncio.create_task(
            update_folder_claudemd(
                manager=self.manager,
                folder_path=folder,
                project=project,
            )
        )
